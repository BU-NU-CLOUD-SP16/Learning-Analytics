id,title,description_html,function_template,test_suite,likes_count,comments_count,created_by,solvers_count,created_at
470,"Scoring for oriented dominoes","<p>Given a list of ordered pairs, and the order they should be placed in a line, find the sum of the absolute values of the differences.</p><pre class=""language-matlab"">list = [1 2
        5 3
        2 4
</pre><pre class=""language-matlab"">order = [1 3 2]
</pre><pre class=""language-matlab"">yields: [1 2][2 4][5 3]
    or: abs(2-2) + abs(4-5)
    or:        0 + 1
    or: 1
</pre><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function score = scoreOrderedDominoes(list, order)
  y = 0;
end","%%
list  = [1 2; 5 4; 2 4];
order = [1 3 2];
y_correct = 1;
assert(isequal(scoreOrderedDominoes(list, order),y_correct))

%%
list = [1 2; 5 4; 2 4];
order = [2 1 3];
y_correct = 3;
assert(isequal(scoreOrderedDominoes(list, order),y_correct))

%%
list = [1 2; 5 4; 2 4; 1 6; 7 5; 4 5; 4 8];
order = [2 1 3 7 4 6 5];
y_correct = 14;
assert(isequal(scoreOrderedDominoes(list, order),y_correct))

%%
list = [1 2; 6 6; 2 4];
order = [2 1 3];
y_correct = 5;
assert(isequal(scoreOrderedDominoes(list, order),y_correct))

%%
list = [1 2; 5 4; 2 4];
order = [1 2 3];
y_correct = 5;
assert(isequal(scoreOrderedDominoes(list, order),y_correct))",5,2,240,321,"2012-03-08 19:58:01"
487,"Find perfect placement of non-rotating dominoes (easier)","<p>Given a list of ordered pairs, find the order they should be placed in a line, such that the sum of the absolute values of the differences is zero.</p><pre class=""language-matlab"">list = [1 2
        4 3
        2 4
</pre><pre class=""language-matlab"">order = [1 3 2]
</pre><pre class=""language-matlab"">yields: [1 2][2 4][4 3]
    or: abs(2-2) + abs(4-4)
    or:        0 + 0
    or: 0
</pre><p>There is a unique solution to this problem where the final score is zero.</p><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function order = findPerfectOrderedDominoes(list)
  order = 0;
end","clear
clc

%%
list  = [     1     5
              2     1
              2     2
              3     2
              4     8
              5     4
              5     5
             10     3];
         
correct = [8     4     3     2     1     7     6     5];
    
assert(isequal(findPerfectOrderedDominoes(list),correct))
%%
list  = [ 1     6
          2     2
          2     7
          7     1
          7     8
          8    10
         10     2
         10    10];
         
correct = [5     6     8     7     2     3     4     1];
    
assert(isequal(findPerfectOrderedDominoes(list),correct))

%%
list  = [1     1
         1     7
         2     4
         4     6
         5     1
         6     2
         7     4
         7     5];
         
correct = [8     5     1     2     7     4     6     3];
    
assert(isequal(findPerfectOrderedDominoes(list),correct))

%%
list  = [1    10
         3    10
         5     3
         6     9
         7     6
         8     7
         8     8
         9     1
        10     5];
         
correct = [7 6 5     4     8     1     9     3     2];
    
assert(isequal(findPerfectOrderedDominoes(list),correct))",2,1,240,147,"2012-03-12 19:23:10"
492,"Find best placement for ordered dominoes (harder)","<p>Given a list of ordered pairs, find the order they should be placed in a line, such that the sum of the absolute values of the differences is <b>minimized</b>.</p><pre class=""language-matlab"">list = [1 2
        5 3
        2 4
</pre><pre class=""language-matlab"">order = [1 3 2]
</pre><pre class=""language-matlab"">yields: [1 2][2 4][5 3]
    or: abs(2-2) + abs(4-5)
    or:        0 + 1
    or: 1
</pre><p>There is a unique best solution, but the score is NOT always zero.</p><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function order = findBestOrderedDominoes(list)
  order = 0;
end","%%
list  = [4     1
         3     4
         1     1
         5     5
         3     5
         0     4
         2     0];
         %2
correct = [2     1     3     7     6     5     4];
    
assert(isequal(findBestOrderedDominoes(list),correct))

%%
list  = [1     1
         2     5
         7     5
         8     1
         1     3
         7     8
         3     6];
         %3
correct = [2     6     4     1     5     7     3];
    
assert(isequal(findBestOrderedDominoes(list),correct))


%%
list  = [8     5
         3     9
        10     6
         6     2
         2    17
        18    14
         9     5];
         %6
correct = [3     1     2     7     4     5     6];
    
assert(isequal(findBestOrderedDominoes(list),correct))",0,0,240,126,"2012-03-13 16:14:19"
520,"Choose the best fitting dominoes","<p>You will be given a cell array of nx2 matrices.  Choose one row from each matrix.  These are the ordered pairs that will be placed in a line like this.</p><pre class=""language-matlab"">{[1 2  [4 5 [0 4
  3 5   2 4  3 2
  1 5]  5 1] 5 3]}
</pre><p>Choices might be: [1 2 3]</p><pre class=""language-matlab"">yields: [1 2][2 4][5 3]
    or: abs(2-2) + abs(4-5)
    or:        0 + 1
    or: 1
</pre><p>You are trying to minimize the score, the absolute difference of the sum of the difference at the intersections.</p><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function order = ChooseBestFittingDominoes(list)
  order = 1;
end","list = {[1 3; 2 4; 5 6],[4 6; 2 5;6 7],[3 4; 6 1; 4 6]}

selections = [2 1 2];

assert(isequal(ChooseBestFittingDominoes(list),selections))


%%

list = {[1 5; 2 3; 2 2; 3 4; 0 3], 
        [0 4; 1 5; 2 2; 4 5; 4 6],
        [7 7; 3 8; 4 7; 5 9; 0 4]};
    
selections = [4 4 4];

assert(isequal(ChooseBestFittingDominoes(list),selections))

%%

list = {[1 4; 2 2; 1 1; 3 3],[1 2; 2 3],[2 2]};

selections = [3 1 1];

assert(isequal(ChooseBestFittingDominoes(list),selections))

",1,1,240,113,"2012-03-22 17:38:21"
534,"Find best domino orientation","<p>Given a list of pairs, find the orientation they should be placed in a line, such that the sum of the absolute values of the differences is zero.</p><p>Zero means do not invert, One means invert in the order vector.</p><pre class=""language-matlab"">list = [1 2
        4 2
        2 3
</pre><pre class=""language-matlab"">order = [0 1 1]
</pre><pre class=""language-matlab"">yields: [1 2][2 4][3 2]
    or: abs(2-2) + abs(4-3)
    or:        0 + 1
    or: 1
</pre><p>There is a unique solution to this problem where the final score is minimized.</p><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function orientation = findBestDominoeOrientation(list)
  y = [];
end","%%
list =  [5     2
         3     7
         4     9
         2     3
         8     2
         3     5
         8     2
         7     8
         4     2
         8     2];
y_correct = [0 0 1 1 1 1 1 1 0 1];
assert(isequal(findBestDominoeOrientation(list),y_correct))

%%
list =  [0     8
         4     8
         2     0
         8     0
         5     7
         7     2
         1     6
         2     6
         2     7
         0     2];
y_correct = [0 1 0 1 1 1 1 0 1 1];
assert(isequal(findBestDominoeOrientation(list),y_correct))

%%
list =  [7     5
         3     1
         5     1
         6     5
         4     8
         2     6
         5     1
         1     3
         5     9
         9     2
         0     7
         1     7];
y_correct = [0 0 1 1 1 0 0 0 0 0 0 1];
assert(isequal(findBestDominoeOrientation(list),y_correct))

%%
list =  [0     4
         0     3
         8     2
         2     5];
y_correct = [1 0 1 1];
assert(isequal(findBestDominoeOrientation(list),y_correct))",0,5,240,113,"2012-03-27 17:33:43"
535,"Rotate and display numbered tile","<p>Imagine a square tile with four numbers on it, one on each edge. We will call these edges north, east, south, and west.</p><p>If the four numbers were [1 5 7 9], this vector would be displayed with the numbers going around clockwise from the north like so:</p><pre>    1  
  9   5
    7  </pre><p>But the tile can appear in four different orientations. Let's say that when the north is 1, then the first number appears in the north position. If north is 2, then the second number appears in the north position, and so on. So if the tile numbers are [1 5 7 9] and the orientation parameter north is 3, then it would display like so, since 7 is the third number:</p><pre>    7  
  5   9
    1  </pre><p>The numbers you are given will always be one or two digit positive integers. You must return a 3-by-6 character array that fits this template:</p><pre class=""language-matlab"">..NN..
WW..EE
..SS..
</pre><p>where dots are used to indicate spaces (ASCII 32). One digit numbers should be right aligned. In the example given immediately above, the output should look like this:</p><pre> Inputs t = [1 5 7 9], north = 3
 Output is  ['   7  '
             ' 5   9'
             '   1  ']</pre><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function td = rotate_tile(t, north)
  t = '';
end","%%
t = [1 5 7 9];
north = 3;
td = ['   7  '
      ' 5   9'
      '   1  '];
assert(isequal(rotate_tile(t, north),td))

%%
t = [27 8 5 46];
north = 4;
td = ['  46  '
      ' 5  27'
      '   8  '];
assert(isequal(rotate_tile(t, north),td))

%%
t = [9 57 75 9];
north = 2;
td = ['  57  '
      ' 9  75'
      '   9  '];
assert(isequal(rotate_tile(t, north),td))
",0,1,7,144,"2012-03-28 20:27:56"
556,"Stuff the Board","<p>You have a stack of tiles to put onto an array-like playing board. Each tile has a number (always an integer), and the board varies in size (you are given dimensions nRows and nCols). You need to put the high-value tiles on the table in any order.</p><p>What you return is an array the same size as the board in which each element is a index to an element of the original vector of tiles.</p><p>Examples:</p><pre> Input tiles = [7 12 8 6 9]
       nRows = 2
       nCols = 2
 Output is [ 1 2
             3 5 ]</pre><p>The numbers in the output matrix can appear in any order. What matters is that the indices [1 2 3 5] do appear and that the index 4 does not appear (since tiles(4) is the lowest number).</p><pre> Input tiles = [12  6  1 20 18  7  4 17]
       nRows = 3
       nCols = 2
 Output is [ 2 6
             4 8
             1 5 ]</pre><p><b>This problem is associated with the <a href=""http://www.mathworks.com/matlabcentral/contest/contests/36"">MATLAB Tiles Contest</a> running from April 4th to April 11th.</b></p><img src=""http://www.mathworks.com/matlabcentral/contest_static/tiles/images/image05.png"">","function board = fill_board(tiles,nRows,nCols)
  board = 0;
end","%%
tiles = [7 12 8 6 9];
nRows = 2;
nCols = 2;

omit = 6;
board = fill_board(tiles,nRows,nCols);
tiles_used = tiles(board(:));
assert(isequal(setdiff(tiles,tiles_used),omit))

%%
tiles = [12  6  1 20 18  7  4 17];
nRows = 3;
nCols = 2;

omit = [1 4];
board = fill_board(tiles,nRows,nCols);
tiles_used = tiles(board(:));
assert(isequal(setdiff(tiles,tiles_used),omit))

%%
tiles = [2 10 25 38 39 5 24 14 4];
nRows = 2;
nCols = 3;

omit = [2 4 5];
board = fill_board(tiles,nRows,nCols);
tiles_used = tiles(board(:));
assert(isequal(setdiff(tiles,tiles_used),omit))
",2,2,7,241,"2012-04-03 17:56:24"
