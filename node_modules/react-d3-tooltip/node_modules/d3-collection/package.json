{
  "name": "d3-collection",
  "version": "0.1.2",
  "description": "Handy data structures for elements keyed by string.",
  "keywords": [
    "d3",
    "nest",
    "data",
    "map",
    "set",
    "object",
    "collection"
  ],
  "homepage": "https://github.com/d3/d3-collection",
  "license": "BSD-3-Clause",
  "author": {
    "name": "Mike Bostock",
    "url": "http://bost.ocks.org/mike"
  },
  "main": "build/d3-collection.js",
  "jsnext:main": "index",
  "repository": {
    "type": "git",
    "url": "https://github.com/d3/d3-collection.git"
  },
  "scripts": {
    "pretest": "mkdir -p build && node -e 'process.stdout.write(\"var version = \\\"\" + require(\"./package.json\").version + \"\\\"; export * from \\\"../index\\\"; export {version};\");' > build/bundle.js && rollup -f umd -n d3_collection -o build/d3-collection.js -- build/bundle.js",
    "test": "faucet `find test -name '*-test.js'` && eslint index.js src",
    "prepublish": "npm run test && uglifyjs build/d3-collection.js -c -m -o build/d3-collection.min.js && rm -f build/d3-collection.zip && zip -j build/d3-collection.zip -- LICENSE README.md build/d3-collection.js build/d3-collection.min.js",
    "postpublish": "VERSION=`node -e 'console.log(require(\"./package.json\").version)'`; git push && git push --tags && cp build/d3-collection.js ../d3.github.com/d3-collection.v0.1.js && cp build/d3-collection.min.js ../d3.github.com/d3-collection.v0.1.min.js && cd ../d3.github.com && git add d3-collection.v0.1.js d3-collection.v0.1.min.js && git commit -m \"d3-collection ${VERSION}\" && git push"
  },
  "devDependencies": {
    "d3-array": "~0.7.0",
    "faucet": "0.0",
    "rollup": "0.25",
    "tape": "4",
    "uglify-js": "2"
  },
  "readme": "# d3-collection\n\nHandy data structures for elements keyed by string.\n\n## Installing\n\nIf you use NPM, `npm install d3-collection`. Otherwise, download the [latest release](https://github.com/d3/d3-collection/releases/latest). The released bundle supports AMD, CommonJS, and vanilla environments. Create a custom build using [Rollup](https://github.com/rollup/rollup) or your preferred bundler. You can also load directly from [d3js.org](https://d3js.org):\n\n```html\n<script src=\"https://d3js.org/d3-collection.v0.1.min.js\"></script>\n```\n\nIn a vanilla environment, a `d3_collection` global is exported. [Try d3-collection in your browser.](https://tonicdev.com/npm/d3-collection)\n\n## API Reference\n\n* [Objects](#objects)\n* [Maps](#maps)\n* [Sets](#sets)\n* [Nests](#nests)\n\n### Objects\n\nA common data type in JavaScript is the *associative array*, or more simply the *object*, which has a set of named properties. The standard mechanism for iterating over the keys (or property names) in an associative array is the [for…in loop](https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in). However, note that the iteration order is undefined. D3 provides several methods for converting associative arrays to standard arrays with numeric indexes.\n\nA word of caution: it is tempting to use plain objects as maps, but this causes [unexpected behavior](http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/) when built-in property names are used as keys, such as `object[\"__proto__\"] = 42` and `\"hasOwnProperty\" in object`. If you cannot guarantee that map keys and set values will be safe, use [maps](#maps) and [sets](#sets) (or their ES6 equivalents) instead of plain objects.\n\n<a name=\"keys\" href=\"#keys\">#</a> d3.<b>keys</b>(<i>object</i>)\n\nReturns an array containing the property names of the specified object (an associative array). The order of the returned array is undefined.\n\n<a name=\"values\" href=\"#values\">#</a> d3.<b>values</b>(<i>object</i>)\n\nReturns an array containing the property values of the specified object (an associative array). The order of the returned array is undefined.\n\n<a name=\"entries\" href=\"#entries\">#</a> d3.<b>entries</b>(<i>object</i>)\n\nReturns an array containing the property keys and values of the specified object (an associative array). Each entry is an object with a key and value attribute, such as `{key: \"foo\", value: 42}`. The order of the returned array is undefined.\n\n```js\nd3.entries({foo: 42, bar: true}); // [{key: \"foo\", value: 42}, {key: \"bar\", value: true}]\n```\n\n### Maps\n\nLike [ES6 Maps](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), but with a few differences:\n\n* Keys are coerced to strings.\n* [map.each](#map_each), not [map.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach). (Also, no *thisArg*.)\n* [map.remove](#map_remove), not [map.delete](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete).\n* [map.entries](#map_entries) returns an array of {key, value} objects, not an iterator of [key, value].\n* [map.size](#map_size) is a method, not a [property](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size); also, there’s [map.empty](#map_empty).\n\n<a name=\"map\" href=\"#map\">#</a> d3.<b>map</b>([<i>object</i>[, <i>key</i>]])\n\nConstructs a new map. If *object* is specified, copies all enumerable properties from the specified object into this map. The specified object may also be an array or another map. An optional *key* function may be specified to compute the key for each value in the array. For example:\n\n```js\nvar map = d3.map([{name: \"foo\"}, {name: \"bar\"}], function(d) { return d.name; });\nmap.get(\"foo\"); // {\"name\": \"foo\"}\nmap.get(\"bar\"); // {\"name\": \"bar\"}\nmap.get(\"baz\"); // undefined\n```\n\nSee also [nests](#nests).\n\n<a name=\"map_has\" href=\"#map_has\">#</a> <i>map</i>.<b>has</b>(<i>key</i>)\n\nReturns true if and only if this map has an entry for the specified *key* string. Note: the value may be `null` or `undefined`.\n\n<a name=\"map_get\" href=\"#map_get\">#</a> <i>map</i>.<b>get</b>(<i>key</i>)\n\nReturns the value for the specified *key* string. If the map does not have an entry for the specified *key*, returns `undefined`.\n\n<a name=\"map_set\" href=\"#map_set\">#</a> <i>map</i>.<b>set</b>(<i>key</i>, <i>value</i>)\n\nSets the *value* for the specified *key* string. If the map previously had an entry for the same *key* string, the old entry is replaced with the new value. Returns the map, allowing chaining. For example:\n\n```js\nvar map = d3.map()\n    .set(\"foo\", 1)\n    .set(\"bar\", 2)\n    .set(\"baz\", 3);\n\nmap.get(\"foo\"); // 1\n```\n\n<a name=\"map_remove\" href=\"#map_remove\">#</a> <i>map</i>.<b>remove</b>(<i>key</i>)\n\nIf the map has an entry for the specified *key* string, removes the entry and returns true. Otherwise, this method does nothing and returns false.\n\n<a name=\"map_clear\" href=\"#map_clear\">#</a> <i>map</i>.<b>clear</b>()\n\nRemoves all entries from this map.\n\n<a name=\"map_keys\" href=\"#map_keys\">#</a> <i>map</i>.<b>keys</b>()\n\nReturns an array of string keys for every entry in this map. The order of the returned keys is arbitrary.\n\n<a name=\"map_values\" href=\"#map_values\">#</a> <i>map</i>.<b>values</b>()\n\nReturns an array of values for every entry in this map. The order of the returned values is arbitrary.\n\n<a name=\"map_entries\" href=\"#map_entries\">#</a> <i>map</i>.<b>entries</b>()\n\nReturns an array of key-value objects for each entry in this map. The order of the returned entries is arbitrary. Each entry’s key is a string, but the value has arbitrary type.\n\n<a name=\"map_each\" href=\"#map_each\">#</a> <i>map</i>.<b>each</b>(<i>function</i>)\n\nCalls the specified *function* for each entry in this map, passing the entry’s value and key as arguments, followed by the map itself. Returns undefined. The iteration order is arbitrary.\n\n<a name=\"map_empty\" href=\"#map_empty\">#</a> <i>map</i>.<b>empty</b>()\n\nReturns true if and only if this map has zero entries.\n\n<a name=\"map_size\" href=\"#map_size\">#</a> <i>map</i>.<b>size</b>()\n\nReturns the number of entries in this map.\n\n### Sets\n\nLike [ES6 Sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set), but with a few differences:\n\n* Values are coerced to strings.\n* [set.each](#set_each), not [set.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach). (Also, no *thisArg*.)\n* [set.remove](#set_remove), not [set.delete](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete).\n* [set.size](#set_size) is a method, not a [property](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size); also, there’s [set.empty](#set_empty).\n\n<a name=\"set\" href=\"#set\">#</a> d3.<b>set</b>([<i>array</i>[, <i>accessor</i>]])\n\nConstructs a new set. If *array* is specified, adds the given *array* of string values to the returned set. The specified array may also be another set. An optional *accessor* function may be specified, which is equivalent to calling *array.map(accessor)* before constructing the set.\n\n<a name=\"set_has\" href=\"#set_has\">#</a> <i>set</i>.<b>has</b>(<i>value</i>)\n\nReturns true if and only if this set has an entry for the specified *value* string.\n\n<a name=\"set_add\" href=\"#set_add\">#</a> <i>set</i>.<b>add</b>(<i>value</i>)\n\nAdds the specified *value* string to this set. Returns the set, allowing chaining. For example:\n\n```js\nvar set = d3.set()\n    .add(\"foo\")\n    .add(\"bar\")\n    .add(\"baz\");\n\nset.has(\"foo\"); // true\n```\n\n<a name=\"set_remove\" href=\"#set_remove\">#</a> <i>set</i>.<b>remove</b>(<i>value</i>)\n\nIf the set contains the specified *value* string, removes it and returns true. Otherwise, this method does nothing and returns false.\n\n<a name=\"set_clear\" href=\"#set_clear\">#</a> <i>set</i>.<b>clear</b>()\n\nRemoves all values from this set.\n\n<a name=\"set_values\" href=\"#set_values\">#</a> <i>set</i>.<b>values</b>()\n\nReturns an array of the string values in this set. The order of the returned values is arbitrary. Can be used as a convenient way of computing the unique values for a set of strings. For example:\n\n```js\nd3.set([\"foo\", \"bar\", \"foo\", \"baz\"]).values(); // \"foo\", \"bar\", \"baz\"\n```\n\n<a name=\"set_each\" href=\"#set_each\">#</a> <i>set</i>.<b>each</b>(<i>function</i>)\n\nCalls the specified *function* for each value in this set, passing the value as the first two arguments (for symmetry with [*map*.each](#map_each)), followed by the set itself. Returns undefined. The iteration order is arbitrary.\n\n<a name=\"set_empty\" href=\"#set_empty\">#</a> <i>set</i>.<b>empty</b>()\n\nReturns true if and only if this set has zero values.\n\n<a name=\"set_size\" href=\"#set_size\">#</a> <i>set</i>.<b>size</b>()\n\nReturns the number of values in this set.\n\n### Nests\n\nNesting allows elements in an array to be grouped into a hierarchical tree structure; think of it like the GROUP BY operator in SQL, except you can have multiple levels of grouping, and the resulting output is a tree rather than a flat table. The levels in the tree are specified by key functions. The leaf nodes of the tree can be sorted by value, while the internal nodes can be sorted by key. An optional rollup function will collapse the elements in each leaf node using a summary function. The nest operator (the object returned by [nest](#nest)) is reusable, and does not retain any references to the data that is nested.\n\nFor example, consider the following tabular data structure of Barley yields, from various sites in Minnesota during 1931-2:\n\n```js\nvar yields = [\n  {yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"},\n  ...\n];\n```\n\nTo facilitate visualization, it may be useful to nest the elements first by year, and then by variety, as follows:\n\n```js\nvar entries = d3.nest()\n    .key(function(d) { return d.year; })\n    .key(function(d) { return d.variety; })\n    .entries(yields);\n```\n\nThis returns a nested array. Each element of the outer array is a key-values pair, listing the values for each distinct key:\n\n```js\n[{key: \"1931\", values: [\n   {key: \"Manchuria\", values: [\n     {yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"},\n     {yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"},\n     {yield: 27.43, variety: \"Manchuria\", year: 1931, site: \"Morris\"}, ...]},\n   {key: \"Glabron\", values: [\n     {yield: 43.07, variety: \"Glabron\", year: 1931, site: \"University Farm\"},\n     {yield: 55.20, variety: \"Glabron\", year: 1931, site: \"Waseca\"}, ...]}, ...]},\n {key: \"1932\", values: ...}]\n```\n\nThe nested form allows easy iteration and generation of hierarchical structures in SVG or HTML.\n\nFor a longer introduction to nesting, see:\n\n* Phoebe Bright’s [D3 Nest Tutorial and examples](http://bl.ocks.org/phoebebright/raw/3176159/)\n* Shan Carter’s [Mister Nester](http://bl.ocks.org/shancarter/raw/4748131/)\n\n<a name=\"nest\" href=\"#nest\">#</a> d3.<b>nest</b>()\n\nCreates a new nest operator. The set of keys is initially empty. If the [map](#nest_map) or [entries](#nest_entries) operator is invoked before any key functions are registered, the nest operator simply returns the input array.\n\n<a name=\"nest_key\" href=\"#nest_key\">#</a> <i>nest</i>.<b>key</b>(<i>function</i>)\n\nRegisters a new key *function*. The key function will be invoked for each element in the input array, and must return a string identifier that is used to assign the element to its group. Most often, the function is implemented as a simple accessor, such as the year and variety accessors in the example above. The function is _not_ passed the input array index. Each time a key is registered, it is pushed onto the end of an internal keys array, and the resulting map or entries will have an additional hierarchy level. There is not currently a facility to remove or query the registered keys. The most-recently registered key is referred to as the current key in subsequent methods.\n\n<a name=\"nest_sortKeys\" href=\"#nest_sortKeys\">#</a> <i>nest</i>.<b>sortKeys</b>(<i>comparator</i>)\n\nSorts key values for the current key using the specified *comparator*, such as [descending](https://github.com/d3/d3-array#descending). If no comparator is specified for the current key, the order in which keys will be returned is undefined. Note that this only affects the result of the entries operator; the order of keys returned by the map operator is always undefined, regardless of comparator.\n\n```js\nvar entries = d3.nest()\n    .key(function(d) { return d.year; })\n    .sortKeys(d3.ascending)\n    .entries(yields);\n```\n\n<a name=\"nest_sortValues\" href=\"#nest_sortValues\">#</a> <i>nest</i>.<b>sortValues</b>(<i>comparator</i>)\n\nSorts leaf elements using the specified *comparator*, such as [descending](https://github.com/d3/d3-array#descending). This is roughly equivalent to sorting the input array before applying the nest operator; however it is typically more efficient as the size of each group is smaller. If no value comparator is specified, elements will be returned in the order they appeared in the input array. This applies to both the map and entries operators.\n\n<a name=\"nest_rollup\" href=\"#nest_rollup\">#</a> <i>nest</i>.<b>rollup</b>(<i>function</i>)\n\nSpecifies a rollup *function* to be applied on each group of leaf elements. The return value of the rollup function will replace the array of leaf values in either the associative array returned by the map operator, or the values attribute of each entry returned by the entries operator.\n\n<a name=\"nest_map\" href=\"#nest_map\">#</a> <i>nest</i>.<b>map</b>(<i>array</i>)\n\nApplies the nest operator to the specified *array*, returning a nested [map](#map). Each entry in the returned map corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions: if there is an additional key, the value is another map; otherwise, the value is the array of elements filtered from the input *array* that have the given key value.\n\n<a name=\"nest_object\" href=\"#nest_object\">#</a> <i>nest</i>.<b>object</b>(<i>array</i>)\n\nApplies the nest operator to the specified *array*, returning a nested object. Each entry in the returned associative array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions: if there is an additional key, the value is another associative array; otherwise, the value is the array of elements filtered from the input *array* that have the given key value.\n\nNote: this method is unsafe if any of the keys conflict with built-in JavaScript properties, such as `__proto__`. If you cannot guarantee that the keys will be safe, you should use [nest.map](#nest_map) instead.\n\n<a name=\"nest_entries\" href=\"#nest_entries\">#</a> <i>nest</i>.<b>entries</b>(<i>array</i>)\n\nApplies the nest operator to the specified *array*, returning an array of key-values entries. Conceptually, this is similar to applying [entries](#nest_entries) to the associative array returned by [map](#nest_map), but it applies to every level of the hierarchy rather than just the first (outermost) level. Each entry in the returned array corresponds to a distinct key value returned by the first key function. The entry value depends on the number of registered key functions: if there is an additional key, the value is another nested array of entries; otherwise, the value is the array of elements filtered from the input *array* that have the given key value.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/d3/d3-collection/issues"
  },
  "_id": "d3-collection@0.1.2",
  "_from": "d3-collection@^0.1.2"
}
